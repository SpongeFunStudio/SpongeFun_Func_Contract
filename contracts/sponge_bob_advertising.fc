#include "imports/stdlib.fc";
#include "imports/op-codes.fc";

global int price_perday;
global int global_ad_index;
global slice admin_address;
global cell ad_map;

const int MIN_TON_FOR_TX = 50000000; ;; 0.05 TON
const int MIN_TON_FOR_STORAGE = 1000000000; ;; 1 TON

;; load_data populates storage variables using stored data
() load_data() impure {

    var ds = get_data().begin_parse();

    price_perday = ds~load_coins();
    global_ad_index = ds~load_uint(64);
    admin_address = ds~load_msg_addr();
    ad_map = ds~load_dict();

    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_coins(price_perday)
            .store_uint(global_ad_index, 64)
            .store_slice(admin_address)
            .store_dict(ad_map)
            .end_cell()
    );
}

(int, cell) unpack_ad_msg(cell ad_cell) {
    if (cell_null?(ad_cell)) {
        return (0, null());
    } else {
        slice ds = ad_cell.begin_parse();
        return (ds~load_uint(64), ds~load_ref());
    }
}

cell pack_ad_msg(cell ad_msg, int finshed_time) {
    return begin_cell()
            .store_uint(finshed_time, 64)
            .store_ref(ad_msg)
            .end_cell();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }

    load_data();
    throw_unless(error::msg_value_not_enough, msg_value < price_perday + MIN_TON_FOR_TX);

    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();

    if (msg_flags & 1) { ;; ignore bounced
        return ();
    }

    slice sender_address = in_msg_full_slice~load_msg_addr();
    (int op, int query_id) = in_msg_body~load_op_and_query_id();
    load_data();

    if (op == op::place_ad) {
        int ad_value = msg_value - MIN_TON_FOR_TX;
        int days = ad_value / price_perday;
        int ad_finished_time = now() + days * 24 * 3600;

        cell ad_msg = in_msg_body~load_ref();
        cell ad_cell = pack_ad_msg(ad_msg, ad_finished_time);

        ad_map~udict_set_ref(256, global_ad_index, ad_cell);
        global_ad_index += 1;
        save_data();

        return ();
    }

    if (op == op::change_price) {
        throw_unless(error::not_owner, equal_slices_bits(sender_address, admin_address));

        price_perday = in_msg_body~load_coins();
        save_data();

        return ();
    }

    if(op == op::withdraw) {

        throw_unless(error::not_owner, equal_slices_bits(sender_address, admin_address));

        int withdraw_amount = in_msg_body~load_coins();
        throw_unless(error::balance_not_enough, my_balance >=  withdraw_amount); ;; Make sure the smc has enough balance
        int send_amount = min(withdraw_amount, my_balance - MIN_TON_FOR_STORAGE);
        throw_unless(error::not_have_enough_amount, send_amount > 0);

        cell msg = begin_cell()
                .store_msg_flags_and_address_none(BOUNCEABLE)
                .store_slice(sender_address) ;; withdraw to owner
                .store_coins(send_amount)
                .store_prefix_only_body()
            .end_cell();

        send_raw_message(msg, SEND_MODE_PAY_FEES_SEPARATELY);
        return ();
    }

    if (op == op::top_up) {
        return (); ;; just accept tons
    }

    throw(error::wrong_op);
}

(int, int, slice, cell) get_ad_status() method_id {
    load_data();
    return (price_perday, global_ad_index, admin_address, ad_map);
}

(int, cell) get_ad_by_index(int index) method_id {
    load_data();
    if(index >= global_ad_index) {
        return (0, null());
    }

    (cell ad_cell, int success) = ad_map.udict_get_ref?(256, index);
    if(success == 0) {
        return (0, null());
    }
    return unpack_ad_msg(ad_cell);
}
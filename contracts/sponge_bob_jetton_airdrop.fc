#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/workchain.fc";

global int seqno; ;; Prevnet replay attack
global int total_claimed;
global int public_key;
global slice sponge_bob_minter_address;
global slice admin_address;

;; load_data populates storage variables using stored data
() load_data() impure {

    var ds = get_data().begin_parse();

    seqno = ds~load_uint(32);
    public_key = ds~load_uint(256);
    total_claimed = ds~load_coins();
    sponge_bob_minter_address = ds~load_msg_addr();
    admin_address = ds~load_msg_addr();
    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(seqno, 32)
            .store_coins(total_claimed)
            .store_uint(public_key, 256)
            .store_slice(sponge_bob_minter_address)
            .store_slice(admin_address)
            .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();

    if (msg_flags & 1) { ;; is bounced
        in_msg_body~skip_bounced_prefix();
        ;; process only mint bounces
        ifnot (in_msg_body~load_op() == op::internal_transfer) {
            return ();
        }
        in_msg_body~skip_query_id();
        int jetton_amount = in_msg_body~load_coins();
        load_data();
        total_claimed -= jetton_amount;
        save_data();
        return ();
    }

    slice sender_address = in_msg_full_slice~load_msg_addr();
    int fwd_fee_from_in_msg = in_msg_full_slice~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of forward_payload costs

    (int op, int query_id) = in_msg_body~load_op_and_query_id();
    load_data();
    if (op == "claim_airdrop"c) {
        var signature = in_msg_body~load_bits(512);
        var hash = slice_hash(in_msg_body);
        throw_unless(401, check_signature(hash, signature, public_key)); ;; Revert on wrong signature

        int msg_seqno = in_msg_body~load_uint(32);
        throw_unless(402, msg_seqno == seqno); ;; Revert if the sequence number of the incoming message does not match the stored sequence number

        int claim_amount = in_msg_body~load_coins();

        cell msg_body = begin_cell()
            .store_op(op::transfer)
            .store_query_id(query_id)
            .store_coins(claim_amount)
            .store_slice(sender_address)
            .store_slice(sender_address)
            .store_int(0, 1)
            .store_coins(0)
            .store_int(0, 1)
            .end_cell();

        cell msg = begin_cell()
            .store_msg_flags_and_address_none(BOUNCEABLE)
            .store_slice(AIRDROP_CONTRACT_ADDRESS)
            .store_coins(0)
            .store_only_body_ref(msg_body)
            .end_cell();

        send_raw_message(
            msg, 
            SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE 
            | SEND_MODE_BOUNCE_ON_ACTION_FAIL
        );
        total_claimed += claim_amount;
        save_data();
    }

    if (op == "mint_to_public_sale_contract"c) {
        throw_unless(error::not_owner, equal_slices_bits(sender_address, admin_address));
        throw_unless(
            error::can_not_start_public_sale, 
            total_claimed >= MAX_SUPPLY * AIRDRP_PERCENTAGE / (2 * DENOMINATOR)
        );

        cell msg_body = begin_cell()
            .store_op("mint_to_public_sale_contract"c)
            .store_query_id(query_id)
            .end_cell();

        cell msg = begin_cell()
            .store_msg_flags_and_address_none(NON_BOUNCEABLE)
            .store_slice(sponge_bob_minter_address)
            .store_coins(0)
            .store_only_body_ref(msg_body)
            .end_cell();

        send_raw_message(
            msg, 
            SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE 
            | SEND_MODE_BOUNCE_ON_ACTION_FAIL
        );
    }

    if (op == op::upgrade) {
        throw_unless(error::not_owner, equal_slices_bits(sender_address, admin_address));
        (cell new_data, cell new_code) = (in_msg_body~load_ref(), in_msg_body~load_ref());
        in_msg_body.end_parse();
        set_data(new_data);
        set_code(new_code);
        return ();
    }

    if (op == op::top_up) {
        return (); ;; just accept tons
    }

    throw(error::wrong_op);
}

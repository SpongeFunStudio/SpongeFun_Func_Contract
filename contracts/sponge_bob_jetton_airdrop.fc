#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/workchain.fc";
;; #include "imports/jetton-utils.fc";
;; #include "imports/gas.fc";

global int seqno; ;; Prevnet replay attack
global int public_key;
global slice sponge_bob_minter_address;
global slice owner_address;

;; load_data populates storage variables using stored data
() load_data() impure {

    var ds = get_data().begin_parse();

    seqno = ds~load_uint(32);
    public_key = ds~load_uint(256);
    sponge_bob_minter_address = ds~load_msg_addr();
    owner_address = ds~load_msg_addr();
    ds.end_parse();
}

;; save_data stores storage variables as a cell into persistent storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(seqno, 32)
            .store_uint(public_key, 256)
            .store_slice(sponge_bob_minter_address)
            .store_slice(owner_address)
            .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();

    if (msg_flags & 1) { ;; is bounced
        ;; in_msg_body~skip_bounced_prefix();
        ;; ;; process only mint bounces
        ;; ifnot (in_msg_body~load_op() == op::internal_transfer) {
        ;;     return ();
        ;; }
        ;; in_msg_body~skip_query_id();
        ;; int jetton_amount = in_msg_body~load_coins();
        ;; load_data();
        ;; total_supply -= jetton_amount;
        ;; save_data();
        return ();
    }

    slice sender_address = in_msg_full_slice~load_msg_addr();
    int fwd_fee_from_in_msg = in_msg_full_slice~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(MY_WORKCHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of forward_payload costs

    (int op, int query_id) = in_msg_body~load_op_and_query_id();
    load_data();
    if (op == "claim_airdrop"c) {
        var signature = in_msg_body~load_bits(512);
        var hash = slice_hash(in_msg_body);
        throw_unless(401, check_signature(hash, signature, public_key)); ;; Revert on wrong signature

        int msg_seqno = in_msg_body~load_uint(32);
        throw_unless(402, msg_seqno == seqno); ;; Revert if the sequence number of the incoming message does not match the stored sequence number

        int claim_amount = in_msg_body~load_coins();
    }
}
